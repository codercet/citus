CREATE SCHEMA on_conflict;
SET search_path TO on_conflict, public;
SET citus.next_shard_id TO 1900000;
CREATE TABLE target_table(col_1 int primary key, col_2 int);
SELECT create_distributed_table('target_table','col_1');
 create_distributed_table 
--------------------------
 
(1 row)

INSERT INTO target_table VALUES(1,2),(2,3),(3,4),(4,5),(5,6);
CREATE TABLE source_table_1(col_1 int, col_2 int, col_3 int);
SELECT create_distributed_table('source_table_1','col_1');
 create_distributed_table 
--------------------------
 
(1 row)

INSERT INTO source_table_1 VALUES(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);
CREATE TABLE source_table_2(col_1 int, col_2 int, col_3 int);
SELECT create_distributed_table('source_table_2','col_1');
 create_distributed_table 
--------------------------
 
(1 row)

INSERT INTO source_table_2 VALUES(6,6,6),(7,7,7),(8,8,8),(9,9,9),(10,10,10);
SET client_min_messages to debug1;
-- Generate series directly on the coordinator and on conflict do nothing
INSERT INTO target_table (col_1, col_2) 
SELECT 
	s, s 
FROM 
	generate_series(1,10) s 
ON CONFLICT DO NOTHING;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
-- Generate series directly on the coordinator and on conflict update the target table
INSERT INTO target_table (col_1, col_2) 
SELECT s, s 
FROM 
	generate_series(1,10) s 
ON CONFLICT(col_1) DO UPDATE SET col_2 = EXCLUDED.col_2 + 1;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
-- Since partition columns do not match, pull the data to the coordinator
-- and do not change conflicted values
INSERT INTO target_table
SELECT 
	col_2, col_3 
FROM
	source_table_1
ON CONFLICT DO NOTHING;
DEBUG:  cannot perform distributed INSERT INTO ... SELECT because the partition columns in the source table and subquery do not match
DETAIL:  The target table's partition column should correspond to a partition column in the subquery.
DEBUG:  Collecting INSERT ... SELECT results on coordinator
-- Since partition columns do not match, pull the data to the coordinator
-- and update the non-partition column
INSERT INTO target_table
SELECT 
	col_2, col_3 
FROM
	source_table_1
ON CONFLICT(col_1) DO UPDATE SET col_2 = EXCLUDED.col_2 RETURNING *;
DEBUG:  cannot perform distributed INSERT INTO ... SELECT because the partition columns in the source table and subquery do not match
DETAIL:  The target table's partition column should correspond to a partition column in the subquery.
DEBUG:  Collecting INSERT ... SELECT results on coordinator
 col_1 | col_2 
-------+-------
     1 |     1
     5 |     5
     3 |     3
     4 |     4
     2 |     2
(5 rows)

-- Subquery should be recursively planned due to the limit and do nothing on conflict
INSERT INTO target_table
SELECT 
	col_1, col_2
FROM (
	SELECT 
		col_1, col_2, col_3 
	FROM
		source_table_1
	LIMIT 5
) as foo
ON CONFLICT DO NOTHING;
DEBUG:  LIMIT clauses are not allowed in distributed INSERT ... SELECT queries
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  push down of limit count: 5
DEBUG:  generating subplan 11_1 for subquery SELECT col_1, col_2, col_3 FROM on_conflict.source_table_1 LIMIT 5
DEBUG:  Plan 11 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('11_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer)) foo
-- Subquery should be recursively planned due to the limit and update on conflict
INSERT INTO target_table
SELECT 
	col_1, col_2
FROM (
	SELECT 
		col_1, col_2, col_3 
	FROM
		source_table_1
	LIMIT 5
) as foo
ON CONFLICT(col_1) DO UPDATE SET col_2 = EXCLUDED.col_2 RETURNING *;
DEBUG:  LIMIT clauses are not allowed in distributed INSERT ... SELECT queries
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  push down of limit count: 5
DEBUG:  generating subplan 14_1 for subquery SELECT col_1, col_2, col_3 FROM on_conflict.source_table_1 LIMIT 5
DEBUG:  Plan 14 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('14_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer)) foo
 col_1 | col_2 
-------+-------
     1 |     1
     5 |     5
     3 |     3
     4 |     4
     2 |     2
(5 rows)

-- Test with multiple subqueries
INSERT INTO target_table
SELECT 
	col_1, col_2
FROM (
	(SELECT 
		col_1, col_2, col_3 
	FROM
		source_table_1
	LIMIT 5)
	UNION
	(SELECT
		col_1, col_2, col_3
	FROM
		source_table_2
	LIMIT 5)
) as foo
ON CONFLICT(col_1) DO UPDATE SET col_2 = 0 RETURNING *;
DEBUG:  Set operations are not allowed in distributed INSERT ... SELECT queries
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  push down of limit count: 5
DEBUG:  generating subplan 17_1 for subquery SELECT col_1, col_2, col_3 FROM on_conflict.source_table_1 LIMIT 5
DEBUG:  push down of limit count: 5
DEBUG:  generating subplan 17_2 for subquery SELECT col_1, col_2, col_3 FROM on_conflict.source_table_2 LIMIT 5
DEBUG:  generating subplan 17_3 for subquery SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('17_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer) UNION SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('17_2'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer)
DEBUG:  Plan 17 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('17_3'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer)) foo
 col_1 | col_2 
-------+-------
    10 |     0
     8 |     0
     5 |     0
     1 |     0
     4 |     0
     7 |     0
     3 |     0
     6 |     0
     2 |     0
     9 |     0
(10 rows)

-- Get the select part from cte and do nothing on conflict
WITH cte AS(
	SELECT col_1, col_2 FROM source_table_1
)
INSERT INTO target_table SELECT * FROM cte ON CONFLICT DO NOTHING;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  generating subplan 22_1 for CTE cte: SELECT col_1, col_2 FROM on_conflict.source_table_1
DEBUG:  Plan 22 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT cte.col_1, cte.col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2 FROM read_intermediate_result('22_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer)) cte) citus_insert_select_subquery
-- Get the select part from cte and update on conflict
WITH cte AS(
	SELECT col_1, col_2 FROM source_table_1
)
INSERT INTO target_table SELECT * FROM cte ON CONFLICT(col_1) DO UPDATE SET col_2 = EXCLUDED.col_2 + 1 RETURNING *;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  generating subplan 25_1 for CTE cte: SELECT col_1, col_2 FROM on_conflict.source_table_1
DEBUG:  Plan 25 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT cte.col_1, cte.col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2 FROM read_intermediate_result('25_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer)) cte) citus_insert_select_subquery
 col_1 | col_2 
-------+-------
     1 |     2
     5 |     6
     3 |     4
     4 |     5
     2 |     3
(5 rows)

-- Test with multiple CTEs
WITH cte AS(
	SELECT col_1, col_2 FROM source_table_1
), cte_2 AS(
	SELECT col_1, col_2 FROM source_table_2
)
INSERT INTO target_table ((SELECT * FROM cte) UNION (SELECT * FROM cte_2)) ON CONFLICT(col_1) DO UPDATE SET col_2 = EXCLUDED.col_2 + 1 RETURNING *;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  generating subplan 28_1 for CTE cte: SELECT col_1, col_2 FROM on_conflict.source_table_1
DEBUG:  generating subplan 28_2 for CTE cte_2: SELECT col_1, col_2 FROM on_conflict.source_table_2
DEBUG:  generating subplan 28_3 for subquery SELECT cte.col_1, cte.col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2 FROM read_intermediate_result('28_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer)) cte UNION SELECT cte_2.col_1, cte_2.col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2 FROM read_intermediate_result('28_2'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer)) cte_2
DEBUG:  Plan 28 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2 FROM read_intermediate_result('28_3'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer)) citus_insert_select_subquery
 col_1 | col_2 
-------+-------
    10 |    11
     8 |     9
     5 |     6
     1 |     2
     4 |     5
     7 |     8
     3 |     4
     6 |     7
     2 |     3
     9 |    10
(10 rows)

WITH cte AS(
	SELECT col_1, col_2, col_3 FROM source_table_1
), cte_2 AS(
	SELECT col_1, col_2 FROM cte
)
INSERT INTO target_table SELECT * FROM cte_2 ON CONFLICT(col_1) DO UPDATE SET col_2 = EXCLUDED.col_2 + 1 RETURNING *;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  generating subplan 33_1 for CTE cte: SELECT col_1, col_2, col_3 FROM on_conflict.source_table_1
DEBUG:  generating subplan 33_2 for CTE cte_2: SELECT col_1, col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('33_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer)) cte
DEBUG:  Plan 33 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT cte_2.col_1, cte_2.col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2 FROM read_intermediate_result('33_2'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer)) cte_2) citus_insert_select_subquery
 col_1 | col_2 
-------+-------
     1 |     2
     5 |     6
     3 |     4
     4 |     5
     2 |     3
(5 rows)

WITH cte AS (
	WITH basic AS (
		SELECT col_1, col_2 FROM source_table_1
	)
	INSERT INTO target_table (SELECT * FROM basic) ON CONFLICT DO NOTHING RETURNING *
)
UPDATE target_table SET col_2 = 4 WHERE col_1 IN (SELECT col_1 FROM cte);
DEBUG:  common table expressions are not supported in distributed modifications
DEBUG:  generating subplan 36_1 for CTE cte: WITH basic AS (SELECT source_table_1.col_1, source_table_1.col_2 FROM on_conflict.source_table_1) INSERT INTO on_conflict.target_table (col_1, col_2) SELECT col_1, col_2 FROM basic ON CONFLICT DO NOTHING RETURNING target_table.col_1, target_table.col_2
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Plan 36 query after replacing subqueries and CTEs: UPDATE on_conflict.target_table SET col_2 = 4 WHERE (col_1 OPERATOR(pg_catalog.=) ANY (SELECT cte.col_1 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2 FROM read_intermediate_result('36_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer)) cte))
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  generating subplan 38_1 for CTE basic: SELECT col_1, col_2 FROM on_conflict.source_table_1
DEBUG:  Plan 38 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT basic.col_1, basic.col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2 FROM read_intermediate_result('38_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer)) basic) citus_insert_select_subquery
-- INSERT .. SELECT with different column types
CREATE TABLE source_table_3(col_1 numeric, col_2 numeric, col_3 numeric);
DEBUG:  building index "pg_toast_22206_index" on table "pg_toast_22206"
SELECT create_distributed_table('source_table_3','col_1');
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "on_conflict" already exists, skipping
DETAIL:  NOTICE from localhost:57637
 create_distributed_table 
--------------------------
 
(1 row)

INSERT INTO source_table_3 VALUES(1,11,1),(2,22,2),(3,33,3),(4,44,4),(5,55,5);
INSERT INTO target_table
SELECT 
	col_1, col_2 
FROM
	source_table_3
ON CONFLICT(col_1) DO UPDATE SET col_2 = EXCLUDED.col_2 RETURNING *;
DEBUG:  cannot perform distributed INSERT INTO ... SELECT because the partition columns in the source table and subquery do not match
DETAIL:  The data type of the target table's partition column should exactly match the data type of the corresponding simple column reference in the subquery.
DEBUG:  Collecting INSERT ... SELECT results on coordinator
 col_1 | col_2 
-------+-------
     5 |    55
     1 |    11
     3 |    33
     4 |    44
     2 |    22
(5 rows)

-- Test with shard_replication_factor = 2
SET citus.shard_replication_factor to 2;
RESET client_min_messages;
DROP TABLE target_table, source_table_1, source_table_2;
CREATE TABLE target_table(col_1 int primary key, col_2 int);
SELECT create_distributed_table('target_table','col_1');
 create_distributed_table 
--------------------------
 
(1 row)

INSERT INTO target_table VALUES(1,2),(2,3),(3,4),(4,5),(5,6);
CREATE TABLE source_table_1(col_1 int, col_2 int, col_3 int);
SELECT create_distributed_table('source_table_1','col_1');
 create_distributed_table 
--------------------------
 
(1 row)

INSERT INTO source_table_1 VALUES(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);
CREATE TABLE source_table_2(col_1 int, col_2 int, col_3 int);
SELECT create_distributed_table('source_table_2','col_1');
 create_distributed_table 
--------------------------
 
(1 row)

INSERT INTO source_table_2 VALUES(6,6,6),(7,7,7),(8,8,8),(9,9,9),(10,10,10);
SET client_min_messages to debug1;
-- Generate series directly on the coordinator and on conflict do nothing
INSERT INTO target_table (col_1, col_2) 
SELECT 
	s, s 
FROM 
	generate_series(1,10) s 
ON CONFLICT DO NOTHING;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
-- Test with multiple subqueries
INSERT INTO target_table
SELECT 
	col_1, col_2
FROM (
	(SELECT 
		col_1, col_2, col_3 
	FROM
		source_table_1
	LIMIT 5)
	UNION
	(SELECT
		col_1, col_2, col_3
	FROM
		source_table_2
	LIMIT 5)
) as foo
ON CONFLICT(col_1) DO UPDATE SET col_2 = 0 RETURNING *;
DEBUG:  Set operations are not allowed in distributed INSERT ... SELECT queries
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  push down of limit count: 5
DEBUG:  generating subplan 48_1 for subquery SELECT col_1, col_2, col_3 FROM on_conflict.source_table_1 LIMIT 5
DEBUG:  push down of limit count: 5
DEBUG:  generating subplan 48_2 for subquery SELECT col_1, col_2, col_3 FROM on_conflict.source_table_2 LIMIT 5
DEBUG:  generating subplan 48_3 for subquery SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('48_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer) UNION SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('48_2'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer)
DEBUG:  Plan 48 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('48_3'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer)) foo
 col_1 | col_2 
-------+-------
    10 |     0
     8 |     0
     5 |     0
     1 |     0
     4 |     0
     7 |     0
     3 |     0
     6 |     0
     2 |     0
     9 |     0
(10 rows)

WITH cte AS(
	SELECT col_1, col_2, col_3 FROM source_table_1
), cte_2 AS(
	SELECT col_1, col_2 FROM cte
)
INSERT INTO target_table SELECT * FROM cte_2 ON CONFLICT(col_1) DO UPDATE SET col_2 = EXCLUDED.col_2 + 1 RETURNING *;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  generating subplan 53_1 for CTE cte: SELECT col_1, col_2, col_3 FROM on_conflict.source_table_1
DEBUG:  generating subplan 53_2 for CTE cte_2: SELECT col_1, col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2, intermediate_result.col_3 FROM read_intermediate_result('53_1'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer, col_3 integer)) cte
DEBUG:  Plan 53 query after replacing subqueries and CTEs: SELECT col_1, col_2 FROM (SELECT cte_2.col_1, cte_2.col_2 FROM (SELECT intermediate_result.col_1, intermediate_result.col_2 FROM read_intermediate_result('53_2'::text, 'binary'::citus_copy_format) intermediate_result(col_1 integer, col_2 integer)) cte_2) citus_insert_select_subquery
 col_1 | col_2 
-------+-------
     1 |     2
     5 |     6
     3 |     4
     4 |     5
     2 |     3
(5 rows)

RESET client_min_messages;
DROP SCHEMA on_conflict CASCADE;
NOTICE:  drop cascades to 4 other objects
DETAIL:  drop cascades to table source_table_3
drop cascades to table target_table
drop cascades to table source_table_1
drop cascades to table source_table_2
